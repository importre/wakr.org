<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=description content="A front-end template that helps you build fast, modern mobile web apps."><meta name=viewport content="width=device-width, initial-scale=1"><title>Web Application Korea</title><meta name=mobile-web-app-capable content=yes><link rel=icon sizes=196x196 href=images/touch/chrome-touch-icon-196x196.png><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black><meta name=apple-mobile-web-app-title content="Web Starter Kit"><meta name=msapplication-TileImage content=/images/touch/ms-touch-icon-144x144-precomposed.png><meta name=msapplication-TileColor content=#3372DF><link rel=stylesheet href=styles/components/main.min.css></head><body><header class="app-bar promote-layer"><div class=app-bar-container><button class=menu><img src=/images/hamburger.svg alt=Menu></button><h1 class=logo>Web Applications Korea</h1><section class=app-bar-actions></section></div></header><nav class="navdrawer-container promote-layer"><h4>Navigation</h4><ul><li><a href=#get-started>Get Started</a></li><li><a href=/2014/08/14/aboutus.html>About</a></li></ul></nav><main><section class="home feeds"><div id=feeds><div class=post><h2>Chrome Enchanted: Notable HTML5 Specifications in 2014<span><sub class=feedurl></sub></span></h2><div><p></p><p>2014년은 HTML5의 정식 Recommended가 예정되어 있으며, 개인적으로 기대하고 있는 몇가지 HTML5 새로운 규격들이 라이브되는 시기이기도 합니다. Web Components, Web Animations, WebRTC, ServiceWorker에 대해 개괄적으로 정리해보았습니다. :)</p><h2 id=html5->2014년에 주목할만한 HTML5 규격들</h2><p>아시다시피 2014년도에도 다양한 HTML5 규격이 작성되고 있거나 구현 단계에 있습니다. <a href=http://dev.w3.org/html5/decision-policy/html5-2014-plan.html#plan title="W3C Plan 2014">W3C는 올해 말 HTML 5.0 표준안을 확정할 예정</a>입니다만 살아있는 표준(Living Standard)로써의 HTML5의 혁신은 지속되고 있습니다. 이번 포스트에서는 현재 시점에서 크롬에 코드가 일부 혹은 전체가 탑재되고 있는 HTML5 규격 중 기존 웹 개발의 패러다임에 변화를 가져올 수 있어 보이는 주목할만한 4가지 규격들에 대해 정리해보았습니다.</p><table><thead><tr><th>주요 HTML5 규격</th><th>설명</th></tr></thead><tbody><tr><td><strong>Web Components</strong></td><td>웹을 위한 컴포넌트 시스템</td></tr><tr><td><strong>Web Animations</strong></td><td>통합된 애니메이션 제어 모델을 제공하기 위한 자바스크립트 API</td></tr><tr><td><strong>WebRTC</strong></td><td>실시간 통신(RealTime Communication)을 지원하기 위한 P2P 통신</td></tr><tr><td><strong>Service Worker</strong></td><td>웹 페이지와 독립적으로 오프라인/시스템 기능을 제공하는 이벤트 기반 Worker</td></tr></tbody></table><h2 id=web-components>1. Web Components</h2><p>Web Components는 (HTML, CSS, JavaScript을 통해) 통상적으로 구성된 웹 페이지 일부 혹은 그 자체를 컴포넌트화하여 다른 웹 페이지 내에서 재사용할 수 있도록 하는 기술입니다. 개인적으로 <code>Web Components</code>를 규격이 아니라 기술이라고 하는 이유는 통상적인 웹 기능과는 달리 4가지의 독립적인 규격의 집합으로 구현할 수 있는 기술이기 때문입니다.</p><blockquote><p>개괄적인 내용은 ‘<a href=http://html5rocksko.blogspot.kr/2014/02/mashup-web-component-evolution-of-web-development.html>웹 컴포넌트: 차세대 프론트엔드 웹 개발로 가는 관문</a>‘이라는 거창한 제목의 포스트에서 다룬 바가 있기 때문에 여기서 이를 복잡하게 다루지는 않을 것입니다. :)</p></blockquote><h3 id=section>웹에서 컴포넌트가 왜 필요할까?</h3><p>‘컴포넌트(Component)’라는 개념은 개발자에게 있어 이미 충분히 친숙한 개념입니다. 소프트웨어 개발에서는 이러한 요소들을 ‘컴포넌트(Component)’라는 개념으로 오랜동안 사용해 왔으며 이미 이미 다양한 형태의 컴포넌트가 각 플랫폼에 적합한 형태로 오랜동안 배포되고 사용되어 왔습니다.</p><p>10여년전과 다를 바 없이 우리는 여전히 다른 프로젝트에서 사용했던 리스트 아이템들을 새로운 프로젝트에서도 적용하기 위해 <em>마크업을 복사해서 수정하고 스타일링을 위한 새로운 CSS를 작성하거나 기존 스타일과의 충돌을 제거하고, 자바스크립트를 최대한 모듈화하여 작성</em>하고 있습니다. 이러한 과정으로 인해 웹 개발자는 개발 프로세스 내에서 언제던지 태그의 바다(Tag Soup)에 빠질 수 있는 가능성을 안고 있습니다. 이제 우리는 조금 더 나아가서 컴포넌트를 웹에서 (특히 프론트엔드 개발에서) 사용할 방법이 필요하며 가능하다면 도구적인 지원을 받을 수 있으면 더 좋을 것입니다.</p><p>다행스럽게도 W3C에서는 이러한 컴포넌트 기술을 웹에서 적용할 수 있도록 새로운 규격의 집합을 만들었으며 이 규격들을 묶어 <code>웹 컴포넌트(Web Component)</code>라고 부르며 이를 지원하는 도구와 라이브러리들의 작업이 여러 곳에서 매우 빠르게 진행되고 있습니다.</p><h3 id=section-1>웹 컴포넌트를 지탱하는 4개의 기둥</h3><p>웹 컴포넌트는 다음과 같은 4가지의 규격으로 구성되어 있습니다.</p><table><thead><tr><th>규격</th><th>설명</th></tr></thead><tbody><tr><td>Shadow DOM</td><td>컴포넌트의 DOM, CSS, JS의 캡슐화(encapsulation)와 스코프(Scope)의 분리를 제공</td></tr><tr><td>HTML Template</td><td>로딩 시간에는 비활성화되는 마크업을 정의하고 이를 실행 시간에 복제할 수 있는 기능을 제공</td></tr><tr><td>Custom Element</td><td>웹 문서에서 사용할 엘리먼트의 동적인 등록을 통해 컴포넌트의 명시적인 alias를 선언</td></tr><tr><td>HTML Imports</td><td>웹 문서 내에 외부 리소스를 포함(Import)하기 위한 기능을 제공</td></tr></tbody></table><p>이를 웹 컴포넌트의 사용 관점에서 좀 더 단순하게 설명하자면 다음과 같습니다.</p><ol><li><strong>HTML Imports</strong>를 이용하여 외부에 존재하는 웹 컴포넌트를 로딩하고,</li><li><strong>Custom Element</strong>로 이를 사용자 태그(Tag)로 지정하여 웹 페이지 내에서 태그가 사용될 떄</li><li><strong>Template</strong>를 통해 웹 컴포넌트의 인스턴스를 생성(Clone)하고,</li><li><strong>Shadow DOM</strong>을 이용하여 생성된 컴포넌트 인스턴스를 웹 페이지 내에서 독립적인 형태로 사용합니다.</li></ol><h4 id=section-2>가장 손쉽게 설명할 수 있는 장점은 역시 재사용성</h4><p>웹 컴포넌트에서 로딩, 등록 등의 신규 규격으로 제공되는 부분을 제거하면 컴포넌트 자체는 순수한 자바스크립트, 마크업, CSS의 덩어리입니다. 즉, <code>웹 페이지</code>의 <strong>일부</strong> 혹은 <strong>그 자체</strong>라고 할 수 있습니다. 필요하다면 우리는 어떠한 페이지를 컴포넌트화해서 사용할 수도 있고, 지금까지 그랬던 것처럼 특정한 컴포넌트를 만들거나 재사용할 수 있습니다.</p><p>물론 최신의 규격을 기반으로 하고 있기 때문에 당장 여러분의 브라우저에서 사용하는데는 무리가 될 수 있습니다만, 필요하다면 <a href="http://www.polymer-project.org/">폴리머(Polymer)</a>나 <a href=https://developer.mozilla.org/en-US/Apps/Tools_and_frameworks/Web_components>Bricks</a>를 사용하여 현재 네이티브로 기능이 지원되지 않는 브라우저에서도 웹 컴포넌트를 사용할 수 있습니다. 현재는 <a href="http://developer.telerik.com/featured/web-components-arent-ready-production-yet/">성능에 대한 논란</a>도 존재합니다만 어쨌든 <a href="http://caniuse.com/#search=web component">크롬 브라우저에서는 완전한 네이티브 구현이 진행되었고, 여타의 브라우저에서도 기능이 일부 지원</a>이 되고 있으므로 참고하시기 바랍니다.</p><h3 id=section-3>참고 링크</h3><h4 id=section-4>규격 관련</h4><ul><li><a href="http://www.w3.org/TR/components-intro/">Introduction to Web Components</a></li><li><a href=https://dvcs.w3.org/hg/webcomponents/raw-file/ccd579693e46/explainer/index.html>Web Components Explainer</a></li><li><a href="http://www.w3.org/TR/shadow-dom/">Shadow DOM</a></li><li><a href="http://www.w3.org/TR/custom-elements/">Custom Element</a></li><li><a href="http://www.w3.org/TR/html-imports/">HTML Imports</a></li><li><a href="http://www.w3.org/TR/html-templates/">HTML Template</a></li></ul><h4 id=polyfill->Polyfill 라이브러리</h4><ul><li><a href="http://www.polymer-project.org/">Polymer Project</a></li><li><a href=https://developer.mozilla.org/en-US/Apps/Tools_and_frameworks/Web_components>Mozilla Bricks</a></li></ul><h4 id=section-5>튜토리얼 및 기타 글</h4><ul><li><a href="http://www.html5rocks.com/ko/tutorials/webcomponents/shadowdom/">Shadow DOM 101</a></li><li><a href="http://www.html5rocks.com/ko/tutorials/webcomponents/shadowdom-201/">Shadow DOM 201</a></li><li><a href="http://www.html5rocks.com/ko/tutorials/webcomponents/shadowdom-301/">Shadow DOM 301</a></li><li><a href="http://www.html5rocks.com/ko/tutorials/webcomponents/customelements/">Custom Elements</a></li><li><a href="http://www.html5rocks.com/ko/tutorials/webcomponents/imports/">HTML Imports</a></li><li><a href="http://www.html5rocks.com/ko/tutorials/webcomponents/template/">Template</a></li><li><a href="http://www.html5rocks.com/ko/tutorials/webcomponents/yeoman/">Building Web Apps With Yeoman And Polymer</a></li><li><a href=http://html5rocksko.blogspot.kr/2014/02/mashup-web-component-evolution-of-web-development.html>웹 컴포넌트: 차세대 프론트엔드 웹 개발로 가는 관문</a></li></ul><h2 id=web-animations>Web Animations</h2><p>오랜동안 웹에서의 애니메이션은 플래시 플레이어가 차지하고 있었습니다만, HTML5 이전에도 SVG(Scalable Vector Graphics)는 자체적인 애니메이션을 구현할 수 있는 방법이 존재하였고 HTML5에 이르러서는 CSS3 Animation과 Transition이 추가되었습니다. 하지만 왜 또 새로운 애니메이션 규격이 제안되었을까요?</p><h3 id=section-6>지금까지의 애니메이션 기능들</h3><p>다들 아시다시피 애니메이션에 관련해서 이미 4종의 규격이 존재하고 있습니다. Web Animations의 목적을 확인하기 전에 잠시 기존 애니메이션 규격들의 단점에 대해 간단하게 확인해보도록 하겠습니다.</p><table><thead><tr><th>규격</th><th>이슈</th></tr></thead><tbody><tr><td><strong>CSS Animation<br>CSS Transition</strong></td><td>조합, 시퀀싱, 병렬 처리 상의 문제점<br>제한적인 스크립트 조작성</td></tr><tr><td><strong>SVG Animation</strong></td><td>고성능 요구 &amp; 복잡성, HTML 컨텐츠에 범용적으로 적용 불가</td></tr><tr><td><strong>requestAnimationFrame()</strong></td><td>JavaScript 기반이므로 애니메이션 업데이트에 메인 스레드 점유</td></tr></tbody></table><p>특히 동적인 애니메이션 제어를 자바스크립트에 위임하는 모델은 확실히 자유도가 높지만 메인 스레드를 점유한다는 선천적인 문제점 그리고 애초에 제어가 불가능한 애니메이션 요소들이 존재하고, CSS 스타일(특히 inline style)에 의한 Recalculation, Layouting, Repaint 등의 이슈를 근본적으로 해결할 수 있는 방법은 아니라는 문제가 있으므로 기존의 규격으로 좋은 성능을 가지는 애니메이션을 개발하는 것은 무척 어렵습니다. 더불어 가장 큰 문제점은 이러한 여러가지 애니메이션 모델을 쉽게 제어할 수 있도록 설계된 단일화된 모델이 존재하지 않는다는 것입니다.</p><h3 id=web-animations-1>2. Web Animations</h3><p>Web Animations는 복잡한 애니메이션을 스크립트로 처리 가능하도록 기존 애니메이션 모델들에 대해 동기화된 API들을 제공하며 기존 4가지 애니메이션 규격에서 처리하기 어려운 부분들을 보완하고 근본적인 구현 사항들을 대체 방안을 제공하는 것이 주요 목적입니다. 이러한 규격을 기초로 얻을 수 있는 가장 큰 장점은 애니메이션 구현에 대한 실행 비용을 브라우저의 구현에 의해 절감할 수 있는 방법이 생긴다는 점 그리고 다양한 애니메이션 기술을 제어하는 공용 API입니다.</p><h4 id=section-7>웹 애니메이션 규격의 범주</h4><p><img src=https://wiki.mozilla.org/images/f/f6/CSS-SVG-Web-Animations.png alt="Web Animations의 범주"></p><p>위의 그림에서 보시다시피 웹 애니메이션의 규격이 포함하는 범주는 매우 넓어보입니다만, 실제로 웹 애니메이션이 추가하고 있는 부분은 어두운 녹색으로 표시되어 있는 애니메이션의 <code>제어</code> 부분이며 애니메이션 방식 자체에 대한 기능은 기존의 CSS3 Animation/Transition, SVG 애니메이션을 그대로 차용합니다.</p><h4 id=api>애니메이션에 대한 동적인 제어를 가능하게 하는 API들</h4><p>개발자들의 관점에서 볼 때 웹 애니메이션은 자바스크립트 기반의 애니메이션 제어 API 세트에 해당하며 웹 애니메이션의 규격을 통해 애니메이션을 처리하는 가장 단순한 예제는 아래와 같습니다.</p><pre><code>&lt;div class="pulse" style="width:150px;"&gt;Hello world!&lt;/div&gt;
&lt;script&gt;
  var elem = document.querySelector('.pulse');
  var player = document.timeline.play(new Animation(elem, [
      {opacity: "0.5", transform: "scale(0.5)"}, 
      {opacity: "1.0", transform: "scale(1)"}
    ],
    {
      direction: "alternate", duration: 500, iterations: Infinity
    }));
&lt;/script&gt;
</code></pre><p>위 코드에서 보다시피 API들은 기존 CSS3 Animation 및 Transition, SVG Animation에 기반하여 애니메이션의 속성을 설정할 수 있습니다.</p><h4 id=section-8>애니메이션 모델 기반의 논리적인 제어</h4><p>웹 애니메이션 규격은 애니메이션과 타이밍 제어를 위한 2가지 모델을 추가하고 있습니다.</p><ul><li>타이밍 모델 - 애니메이션의 재생 시간, 반복, 재생 속도 등의 속성을 기반으로 한 타임 라인 제어</li><li>애니메이션 모델 - 타이밍 모델에서 처리된 시간값을 기반으로 정의된 애니메이션의 처리</li></ul><p><img src=http://dev.w3.org/fxtf/web-animations/img/timing-and-animation-models.svg alt="Web Animations - Timing Model &amp; Animation Model"></p><p>웹 애니메이션에서 타이밍 모델을 전반적으로 애니메이션을 위한 시간 값을 처리하며, 처리된 시간 값은 정의된 애니메이션에서 재생을 위한 위치 값으로 활용됩니다. 예를 들자면 left 값이 0px에서 100px로 변경되는 애니메이션이 존재할 때 타이밍 모델에서 처리된 시간값이 애니메이션 모델에 입력으로 들어와서 50%에 해당하는 위치 값을 가진다면 애니메이션 모델의 출력값은 <code>left: 50px;</code>이 될 것입니다.</p><h4 id=section-9>선언적인 애니메이션 구조에서의 탈피가 가장 큰 의미</h4><p>얼핏 보자면 API화 되어 있다는 점 외에는 기존의 기능과 크게 틀린 부분이 보이지는 않을 것이라고 생각되지만, 애니메이션의 대상이 되는 DOM 요소를 논리적인 트리 형태로 포함할 수 있는 기능을 가지고 있습니다. 또한, 타이밍 모델은 기본적인 타이밍의 제어룰 제공합니다만, 타이밍 그룹(Timing Group)을 통해 계층적인 제어가 가능하며 동적으로 애니메이션의 재생 속성을 변경할 수 있으며, 재생시간 등의 속성이 미리 선언되어야 하는 기존 방식과는 다른 편리함을 가지고 있습니다. 이에 대한 자세한 내용은 이후의 다른 포스트에서 다뤄보도록 하겠습니다. :)</p><h4 id=section-10>초기 단계지만 구현 상황에 대한 지속적인 관심이 필요</h4><p>크롬을 기준으로 보자면 Blink의 Animation 및 Transition 엔진이 작년 말에 웹 애니메이션을 지원하기 위한 구조로 이미 변경되었으며 현재 <a href=http://updates.html5rocks.com/2014/05/Web-Animations---element-animate-is-now-in-Chrome-36>36 버전에서 <code>Element.animate()</code>가 구현된 상태</a>이며 나머지 기능들이 계속 구현 진행 중입니다. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=875219">모질라</a>와 <a href=https://lists.webkit.org/pipermail/webkit-dev/2013-October/025758.html>사파리</a>는 네이티브 구현은 진행 단계에 있으며 <a href=http://status.modern.ie/webanimationsjavascriptapi>IE의 경우 구현에 대해 고려 중</a>입니다. 그 외에도 <a href=https://github.com/web-animations/web-animations-js>웹 애니메이션 폴리필 라이브러리</a>를 이용하여 웹 애니메이션을 다른 HTML5 기반의 브라우저에서 실행할 수 있습니다.</p><p>물론 전반적인 규격과 폴리필, 크롬에서의 구현을 포함하여 아직은 초기 단계이기 때문에 당장 사용하기에는 일부 어려운 점이 있습니다. 다만, 웹 애니메이션이 <a href=http://www.polymer-project.org/platform/web-animations.html>폴리머에 포함</a>된 상태이며 그간 플래시가 차지하고 있었던 웹에서의 애니메이션 기능을 위한 대체 기술로써 고안되었으므로 이에 대한 관심은 지속적으로 가질 필요가 있습니다.</p><h3 id=section-11>참고 링크</h3><h4 id=section-12>규격 관련</h4><ul><li><a href="http://dev.w3.org/fxtf/web-animations/">W3C Web Animations Specification</a></li></ul><h4 id=polyfill--1>Polyfill 라이브러리</h4><ul><li><a href=https://github.com/web-animations/web-animations-js>Web Animations.js</a></li></ul><h4 id=section-13>튜토리얼 및 기타 글</h4><ul><li><a href=http://www.polymer-project.org/platform/web-animations.html>Polymer - Web Animations</a></li><li><a href="http://web-animations.github.io/web-animations-demos/">Web Animations Demo</a></li><li><a href=http://updates.html5rocks.com/2014/05/Web-Animations---element-animate-is-now-in-Chrome-36>Web Animations - element.animate() is now in Chrome 36</a></li></ul><h2 id=webrtc>3. WebRTC</h2><p>Ajax를 비롯한 HTTP(S) 기반의 통신은 오랜동안 요청/응답(Request and Response) 기반의 모델을 취해왔습니다. 물론 네트워크 데이터의 대부분은 요청에 의한 응답으로 충분히 처리가 가능합니다만, 보다 고성능의 네트워크를 필요로 하는 현대적 서비스들은 이러한 부분에서 어려움을 겪어왔습니다. 이를 해결하기 위한 첫번째 움직임은 2012년 제정된 <a href="http://www.w3.org/TR/websockets/">Web Socket</a>이었습니다. 그리고 웹 소켓이 해결하지 못하는 P2P 기반의 네트워크를 위한 규격이 바로 WebRTC입니다.</p><h3 id=p2p-->웹을 위한 P2P 통신 규격</h3><p>WebRTC는 웹을 위한 실시간 통신 규격으로 오디오나 비디오 스트림을 P2P로 송수신하는 것뿐만이 아니라 데이터 전달을 위한 메커니즘을 포함하고 있습니다.</p><p>대다수의 서비스들은 클라언트-서버 간의 데이터 통신을 통해 기능을 제공하고 있지만 어떤 경우는 클라이언트 간의 빠른 데이터 교환이 주요 기능 구현 사항이 되기도 합니다. 바로 이러한 경우 WebRTC는 중요한 기반 기능을 제공합니다. 뒤집어 얘기하자면 서버를 중계할 이유가 없으며 클라이언트 간의 데이터를 빠르게 송수신하고자 한다면 WebRTC는 좋은 선택이 될 수 있습니다.</p><p><img src=http://www.html5rocks.com/ko/tutorials/webrtc/basics/apprtcArchitecture.png alt="Architecture of WebRTC application"></p><h4 id=section-14>단지 성능이 아닌 신뢰성과 보안을 포함하는 규격</h4><p>WebRTC는 문자열, Blob, ArrayBuffer 그리고 자바스크립트 바이너리 타입을 지원하며 UDP와 유사한 ‘신뢰성 없는 모드’와 TCP과 유사한 ‘신뢰성 있는 모드’ 둘 중 하나로 동작할 수 있습니다. 신뢰성 있는 방식(Trusted Mode)은 메시지 전송과 메시지가 전달되는 순서를 보장하지만 추가적인 오버헤드가 있으며 신뢰성 없는 방식(Untrusted Mode)은 모든 메시지가 상대편에 도달하는지와 어떤 순서로 도달하는지를 보장하지 않는 대신 오버헤드를 제거합니다.</p><p>또한, <strong>암호화(Encryption)는 WebRTC 요소의 기본 사항</strong>입니다. 모든 데이터가 데이터그램 전송 계층 보안 (Datagram Transport Layer Security, DTLS)을 사용하도록 정의되어 있으므로 WebRTC를 지원하는 모든 브라우저가 DTLS를 내장하고 있으므로 추가적인 구현없이도 안전한 데이터 송수신이 가능합니다.</p><h4 id=section-15>가장 대표적인 사례는 비디오 채팅</h4><p>지난 세월동안 오디오와 비디오 캡쳐는 외부 플러그인들을 사용할 수 밖에 없었으나 HTML5는 다양한 하드웨어에 대한 접근을 표준 규격으로 정의하고 있으며 오디오와 비디오의 캡쳐 역시 그렇습니다. 이와 관련해서 그동안 다양한 규격들이 W3C에서 시도되어 왔지만 현재 <a href=https://developer.mozilla.org/en-US/docs/NavigatorUserMedia.getUserMedia>getUserMedia()</a>를 통해 대다수의 작업을 할 수 있도록 정리되었습니다. WebRTC의 가장 대표적인 사례는 바로 이 getUserMedia()를 결합하여 별도의 플러그인 없이 구현할 수 있는 P2P 기반의 비디오 채팅입니다.</p><h4 id=section-16>게임 등에도 응용이 가능한 범용 규격</h4><p>이러한 대표적인 사례로 인해 WebRTC는 종종 화상 회의와 같은 미디어 통신을 위한 규격처럼 인식되는 경우가 있으나 그렇지 않습니다. 화상회의와 같은 것은 WebRTC의 P2P 통신과 mediaCapture()이 결합된 좋은 사례 중 하나일 뿐입니다. 물론 커뮤니케이션, 게임, 혹은 파일 전송을 위한 두 브라우저 간의 데이터 전송은 상당히 복잡한 과정일 수 있습니다. 우리에게는 WebSocket, AJAX, 그리고 Server Sent Events가 있지만 이는 근본적으로 서버를 통한 통신 모델로써의 디자인입니다.</p><p>WebRTC는 근본적으로 P2P를 기반으로 하는 데이터 전송 메커니즘입니다. 이는 파일 전송뿐만이 아니라 P2P를 기반으로하는 멀티플레이어 게임에도 유용합니다. 이를 위한 RTCDataChannel은 파일 공유, 멀티플레이어 게임, 콘텐츠 전송을 위한 앱을 만드는 새로운 방식을 제공합니다. 이를 사용하여 낮은 지연 시간을 가지는 고성능 네트워크 어플리케이션을 제공할 수 있으며, 한 피어(peer)에서 다른 곳으로 직접 데이터를 전달하기 위해 P2P(peer-to-peer) 연결을 가능하게 하여 중개 서버가 없고 ‘홉(hops)’이 적어 지연 시간을 더 줄일 수 있습니다.</p><h3 id=section-17>참고 링크</h3><h4 id=section-18>규격</h4><ul><li><a href="http://www.w3.org/TR/webrtc/">WebRTC - W3C Working Draft</a></li><li><a href=http://dev.w3.org/2011/webrtc/editor/getusermedia.html>getUserMedia()</a></li></ul><h4 id=section-19>튜토리얼 및 기타 글</h4><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/Guide/API/WebRTC/WebRTC_basics>MDN - WebRTC Basics</a></li><li><a href="http://www.html5rocks.com/ko/tutorials/webrtc/basics/">Getting Started with WebRTC</a></li><li><a href="http://www.html5rocks.com/ko/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN and signaling</a></li><li><a href="http://www.html5rocks.com/ko/tutorials/webrtc/datachannels/">WebRTC data channels: WebRTC data channels: for high performance data exchange</a></li></ul><h2 id=service-worker>4. Service Worker</h2><p>현재의 네이티브 앱들의 기능과 유사한 형태의 웹 어플리케이션을 구현할 때 가장 난해한 부분은 어떤 것일까요? 아마 그래픽스, 성능, 네트워크 등 다양한 의견이 나올 거이라고 생각됩니다만, 최소한 이들 기능은 현재 HTML5에서의 기능들에 의한 대체제가 존재합니다. 단연컨데 현재 가장 어려운 부분 중의 하나는 <code>오프라인</code>입니다. Service Worker는 1차적으로는 이러한 오프라인의 문제를 해결하기 위한 시작점입니다. 물론 Service Worker가 커버하는 범위는 이보다 더 넓습니다만, 요약하자면 <strong>네이티브 어플리케이션의 동작 흐름을 웹으로 가져오기 위한 가장 중요한 기능</strong>이라고 할 수 있겠습니다.</p><h3 id=section-20>오프라인을 지원하기 위한 두번째 규격</h3><p>서비스 워커 이전의 가장 대표적인 문제점은 역시 오프라인 리소스에 대한 관리입니다. 이전에도 <a href=http://www.whatwg.org/specs/web-apps/current-work/#applicationcache>Application Cache</a>를 이용하여 일종의 Packaged App을 지원하고 오프라인 기반의 웹 어플리케이션을 지속적으로 시도해왔습니다.</p><h4 id=section-21>로직 기반의 오프라인 리소스 관리</h4><p>Application Cache의 경우 캐싱 처리를 정적인 분기 로직을 기반으로 동작시켜야 했으며, 대체적으로 개발자가 원하던 방식보다는 <strong>브라우저의 정책에 따라 리소스가 관리</strong>되는 문제가 존재하였습니다. 대표적인 문제점들은 다음과 같이 <a href=http://alistapart.com/article/application-cache-is-a-douchebag>Application Cache is a douchebag</a>에서 지적된 내용들입니다.</p><blockquote><ol><li>온라인에 있을 때에도 파일들이 언제나 어플리케이션 캐시로부터 전달된다.</li><li>어플리케이션 캐시는 Manifest 자체가 변경될 때만 업데이트된다.</li><li>어플리케이션 캐시는 선택적이지 않은 추가적이 캐시(동작)이다.</li><li>절대로 한참 후의 manifest를 캐시하지 않는다.</li><li>캐싱되지 않은 리소스는 캐시된 페이지에서 로딩되지 않는다.</li></ol></blockquote><p><img src=http://cwdoh.com/images/notable-specs-2014/OMG.appcache.png alt=Offline></p><p>서비스 워커는 이를 해결하기 위해 프로그램 가능(Programmable)한 오프라인 리소스의 근본적인 처리 방법을 제시합니다. 브라우저에서 일어나는 요청(Request)들을 조건에 따라 인터럽트하여 직접 응답(Custom response)할 수 있는 기능을 통해 사용자가 직접 리소스를 관리할 수 있습니다. 따라서 캐시 로직은 사용자가 직접 작성이 가능하며 언제든지 업데이트할 수 있습니다.</p><p><img src=http://cwdoh.com/images/notable-specs-2014/serviceworker_cache_flow.png alt="Service Worker - Controlling fetch flow"></p><h4 id=section-22>페이지 기반이 아닌 백그라운드 기반의 프로세싱 지원</h4><p>익히 아시다시피 웹 어플리케이션은 브라우저 상에서 페이지 단위로 동작합니다. 이를 뒤집어 보자면 페이지가 로딩되지 않은 상황에서의 처리들이 불가능하다는 말과도 같습니다. 아마 기획 과정에서 요구되는 네이티브 어플리케이션 형태의 동작들, 예를 들어 Remote Push Notification과 같은 항목들 이로 인해 구현이 불가능하였습니다. 서비스워커는 시스템 이벤트에 대한 콜백 시스템을 제공하여 이러한 부분을 해결하고자 하고 있습니다. 물론 세부적인 기능들은 서비스 워커 자체에서 지원하는 것은 아닙니다만, 앞으로 백그라운드 프로세싱을 사용하는 대다수의 기능은 서비스 워커를 기반으로 동작할 것입니다. 현재 디자인되고 있는 규격들은 다음과 같이 원격 푸시, 스케쥴 기반의 로컬 알람, 백그라운드 동기화입니다.</p><p>원격 푸시 알림의 경우 네이티브에서도 익히 아실 듯하고, 태스크 스케쥴러는 웹 페이지가 로딩되지 않은 상태에서도 스케쥴링된 알람에 의해 특정한 동작을 수행할 수 있으며, 백그라운드 동기화를 통해 오프라인 상태에서의 업데이트된 데이터를 다음 온라인 시에 동기화할 수 있는 기능들을 제공합니다.</p><ol><li><a href=https://dvcs.w3.org/hg/push/raw-file/tip/index.html>Push API</a></li><li><a href="http://www.w3.org/2012/sysapps/web-alarms/">Task Schedular API(a.k.a. Local alarm)</a></li><li><a href=https://github.com/slightlyoff/BackgroundSync>Background Synchronization</a></li></ol><h3 id=section-23>가장 큰 패러다임 변화가 예상</h3><p><code>서비스 워커</code>는 <code>웹 컴포넌트</code>와 마찬가지로 네이티브 어플리케이션 개발자 입장에서는 익숙한 개념들을 가지고 있습니다. 다만, <code>웹 컴포넌트</code>가 컴포넌트의 재사용성을 추구하는 개념이라면 <code>서비스 워커</code>는 웹 어플리케이션의 근본적인 한계를 탈출하기 위한 내용을 담고 있습니다. 반대로 보자면 웹 어플리케이션 개발자 관점에서는 다소 익숙하지 않은 형태의 많은 개발 형태를 예고하고 있습니다. 하지만, 웹 어플리케이션의 오프라인 기능 지원이 일반화되고 있는 지금 반드시 익숙해져야 하는 대표적인 기능이기도 합니다.</p><p>서비스 워커는 그 특성상 폴리필 라이브러리를 제공할 수 없습니다만, 현재 크롬이 서비스워커의 첫번째 네이티브 구현을 포함하고 있습니다. 아직 캐시 API는 폴리필 형태로 제공하고 있습니다만, 대체적인 기능은 현재도 사용이 가능합니다. Google I/O 2014에서 폴리머 데모로 소개된 <a href="http://www.polymer-project.org/apps/topeka/">Topeka</a>는 로딩 타임의 제거를 위해 <a href=http://www.polymer-project.org/apps/topeka/sw.js>모든 리소스를 초기에 로딩하는 기능을 서비스 워커로 구현</a>하고 있습니다. 코드를 참조하시는 것만으로도 충분하게 기능을 확인해 볼 수 있을 것입니다.</p><h3 id=section-24>참고 링크</h3><h4 id=section-25>규격 관련</h4><ul><li><a href="http://www.w3.org/TR/service-workers/">Service Worker - W3C repository</a></li><li><a href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/">Service Worker - Working repository</a></li><li><a href=https://github.com/slightlyoff/ServiceWorker/blob/master/explainer.md>Explainer</a></li><li><a href=https://github.com/slightlyoff/ServiceWorker/blob/master/implementation_considerations.md>Implementation Considerations</a></li></ul><h4 id=section-26>튜토리얼 및 기타 글</h4><ul><li><a href="http://jakearchibald.com/2014/service-worker-first-draft/">ServiceWorker first draft is published</a></li><li><a href="https://jakearchibald.github.io/isserviceworkerready/">Is ServiceWorker ready?</a></li><li><a href=http://www.slideshare.net/jungkees/service-workers>Service Worker: Bring your own magic! (Slide)</a></li><li><a href=http://www.slideshare.net/cwdoh/serviceworker-new-game-changer-is-coming>ServiceWorker: New Game Changer is coming! (Slide)</a></li></ul><p></p><p><a href=/html5/2014/08/18/chrome-enchanted-notable-html5-specs-in-2014.html>18 Aug 2014</a> - <a>+</a></p></div><div class=post><h2>About us<span><sub class=feedurl></sub></span></h2><div><p></p><p>Hi. We are interested in (Natively) Web Applications</p><p></p><p><a href=/2014/08/14/aboutus.html>14 Aug 2014</a> - <a href=https://plus.google.com/107574899030973045541/about>+ragingwind</a></p></div><div class=post><h2>Polymer at Google I/O 2014<span><sub class=feedurl></sub></span></h2><div><p></p><p>이번 Google I/O 2014 에서 웹에 관련된 세션에서 가장 주목 받는 기술은 Polymer 와 Web Components 였습니다. 특히 Polymer 는 메터리얼 디자인 (Material Design) 을 구현한 <a href=http://goo.gl/pr1IyR>Paper Elements</a> 릴리즈 했습니다. 이제 Android 제품군을 포함하여 Chrome Apps 을 포함한 다른 Web Application 에서도 동일한 메터리얼 디자인을 제공하여 Android 와 Web 환경에서 통일된 UX 를 경험할 수 있게 되었습니다. Google I/O 2014 에서 있었던 세션과 관련 자료들을 모아봤습니다.</p><h3 id=polymer-and-web-components-change-everything-you-know-about-web-development>Polymer and Web Components change everything you know about Web development</h3><p>크롬팀의 <a href=http://goo.gl/ThKsWQ>Eric Bidelman</a> 이 Web Components 와 관련된 역사와 현재 상황 그리고 Custom Elements, Shadow DOM, Template, HTML Imports 에 대한 기술적인 소개와 Polymer 의 구성요소와 Polymer 로 구현된 사례를 소개 합니다.</p><iframe width=560 height=420 src="http://www.youtube.com/embed/8OJ7ih8EE7s?color=white&amp;theme=light"></iframe><ul><li><a href=http://goo.gl/PcE1R>Welcome - Polymer</a></li><li><a href=http://goo.gl/my18Rj>polymer - Github</a></li><li><a href=http://goo.gl/JYGur0>Google Web Components</a></li><li><a href=http://goo.gl/193a1S>Polymer &amp; Web Components - Google I/O 2014</a></li></ul><h3 id=polymer-and-the-web-components-revolution>Polymer and the Web Components revolution</h3><p>Polymer 팀을 리딩하는 <a href=http://goo.gl/ZbqWOq>Matthew McNulty</a> 이 Polymer 의 철학과 간단한 사용법을 포함한 오버뷰와 에코시스템 그리고 <a href=http://goo.gl/pr1IyR>Paper Elements</a> 와 같이 메터리얼 디자인에 대해서 소개합니다. 특히 메터리얼 디자인으로 만들어진 <a href=http://www.polymer-project.org/apps/topeka/index.html>Topeka 퀴즈앱</a> 예제를 통해서 메터리얼 디자인과 Polymer 로 어떻게 구현되었는지 알 수 있습니다.<br></p><iframe width=560 height=420 src="http://www.youtube.com/embed/yRbOSdAe_JU?color=white&amp;theme=light"></iframe><ul><li><a href=http://goo.gl/sVr8sl>Polymer Designer</a></li></ul><h3 id=unlock-the-next-era-of-ui-development-with-polymer>Unlock the next era of UI development with Polymer</h3><p>Google Developer Advocate 인 <a href=http://goo.gl/TQkslB>Rob Dodson</a> 가 Polymer 의 실제 사용법과 특징을 상세히 소개 합니다. 이전 세션 보다는 고급과정이며 Polymer 의 실제 코드를 통해서 Polymer 의 동작을 알아봅니다.</p><iframe width=560 height=420 src="http://www.youtube.com/embed/HKrYfrAzqFA?color=white&amp;theme=light"></iframe><ul><li><a href=http://goo.gl/OcgQf0>Unlock the next era of UI design with Polymer</a></li></ul><h3 id=codelab>Codelab</h3><p>Google I/O 에서는 아래와 같은 Codelab 이 진행되었습니다. 진행을 위해서는 <a href=http://io2014codelabs.appspot.com/setup/#polymer>코드랩 설치준비</a> 를 하시고 <a href=http://goo.gl/ktGHLl>Chrome Dev Editor (developer preview)</a> 를 설치하세요.</p><ul><li><a href=http://goo.gl/4EpM3B>Polymer: Build a Google Maps App Using Web Components &amp; No Code!</a></li><li><a href=http://goo.gl/RKH769>Polymer: Build a Material Design Mobile Web App with Paper Elements</a></li><li><a href=http://goo.gl/GlQzqY>Polymer: Build a Mobile Drive Client</a></li><li><a href=http://goo.gl/S1eZh5>Polymer: Build an Admin Console Using Dart</a></li></ul><p></p><p><a href=/2014/07/02/polymer-at-googleio.html>02 Jul 2014</a> - <a href=https://plus.google.com/107574899030973045541/about>+ragingwind</a></p></div><div class=post><h2>Monthly Digest for Web Applications<span><sub class=feedurl></sub></span></h2><div><p></p><p><code>Monthly Digest for Web Applications</code> 에서는 Web Applications 개발에 관련된 소식을 모아서 간단한 코멘트와 함께 전달해 드립니다.</p><h2 id=chrome-apps>Chrome Apps</h2><ul><li><a href=http://goo.gl/34GqKt>Minimize button for Window</a>: minimize button 이 드디어? #dev, #chromeos</li><li><a href=http://goo.gl/xqZJ8f>Multiple profiles on Chrome OS</a>: <code>chrome://flags/#enable-multi-profiles</code> 를 통해서 바로 다른 profile 이 적용 가능합니다. #dev,,#chromeos</li><li><a href=http://goo.gl/bXlHna>Close windows directly from the Overview mode</a>: Overview 모드에서 바로 종료가 해졌습니다. #dev, #chromeos</li><li><a href=http://goo.gl/HI5Mhu>CCA (Cordova Chrome App) updated for Chrome Apps on Mobile</a>: Cordova 를 사용해서 모바일에서 Chrome App 을 만들 수 있는 <a href=http://goo.gl/nU5O6U>CCA</a> 가 업데이트 되었습니다. #chromemobile</li><li><a href=http://goo.gl/pJGYWp><code>chrome.sessions</code> API</a>: <code>chrome.sessions</code> API 에 여러 이벤트들이 추가되어서 tab 의 close 이벤트를 핸들링 할 수 있습니다. #dev</li><li><a href=http://goo.gl/iFzYaL><code>chrome.accessibilityFeatures</code> API</a>: <code>chrome.accessibilityFeatures</code> experimental Chrome Extension library 가 추가되었습니다. 개별적인 Accessibility 장치들 (Large cursor, Virtual keyboard) 에 대해서 접근 할 수 있습니다. #dev, #chromeos</li><li><a href=http://goo.gl/q9YImo>IME extensions</a>: <code>&lt;shift&gt;+&lt;space&gt;</code> 로 IME 변경이 가능합니다. #dev #chromeos</li><li><a href=http://goo.gl/sgAaui>Video Player Chrome App</a>: 비디오 플레이어가 별도의 Chrome App 으로. #chromeos, #dev</li><li><a href=http://goo.gl/j1ZbjK>Chrome apps/extensions commands global scope</a>: Chrome apps / extensions 에서 keyboard shortcuts 이 사용 가능해졌습니다. 그래서 Google music mini player 를 포커스를 주지 않아도 제어 가능합니다. #dev</li><li><a href=http://goo.gl/4rzkJN>Chrome App windows bounds API</a>: inner/outter Bound properties 가 추가되었습니다. window 의 decorations 포함여부가 중요합니다. #dev</li><li><a href=http://goo.gl/UYdsBR>Chrome App NFC Library is now open-source</a>: <a href=http://goo.gl/1odqXO>Chrome App NFC Library</a> 가 Open source 로 공개되었습니다. 현재 지원되는 장비는 2대 정도이고 <code>chrome.nfc</code> 로 사용 가능합니다.</li><li><a href=http://goo.gl/Hp6L7l>Web Store API to programmatically create, update and publish items in the Web Store</a>: RESTful API 로 Web Store 를 컨트롤 할 수 있습니다. <a href=http://goo.gl/3dVfG1>web-store</a> 을 참고하세요.</li><li><a href=http://goo.gl/oLpyb8>App Info Dialog</a>: <code>chrome://flags/#enable-app-list-info</code> 를 통해서 App Info 가 확인 가능해졌습니다. #canary</li><li><a href=http://goo.gl/sT7aAU>chrome.webstore API for inline installation</a>: <code>&lt;link&gt;</code> 태그와 <code>chrome.webstore</code> 를 이용하여 inline 으로 설치가 가능합니다. #chromium</li><li><a href=http://goo.gl/EE1zaG>Mobile Chrome Apps and Android Wear</a>: Mobile Chrome Apps 에서 <code>chrome.notifications</code> API 를 사용하여 Android Wear 와 연동하는 방법입니다. #chromemobile</li><li><a href=http://goo.gl/e2Gth7>Chrome Apps <code>&lt;webview&gt;</code> with context menus</a>: <code>&lt;webview&gt;</code> 에 <code>chrome.contextMenus</code> API 를 이용하여 context menu 를 설정할 수 있습니다. #chromium</li><li><a href=http://goo.gl/gfCxzk>ServiceWorkers internal page</a>: ServiceWorkers 를 위한 <code>chrome://serviceworker-internals</code> internal page 가 생겼습니다. <code>chrome://flags/#enable-service-worker</code> 를 이용해서 사용가능합니다. #chromium</li><li><a href=http://goo.gl/OGKbG5>Perform a simple search in a Chrome App <code>&lt;webview&gt;</code></a>: 생성된 <code>&lt;webview&gt;</code> 에서 <code>webview.find</code> 로 문자열 검색이 가능합니다. #chromium</li><li><a href=http://goo.gl/BSrZRr>Handle URLs by Chrome Apps</a>: <code>url_handlers</code> 에 URL Pattern 을 등록해서 해당 url 에 접근시 <code>app.runtime.onLaunched</code>로 이벤트가 발생해서 추가적인 작업을 할 수 있도록 해줍니다. #chromium</li><li><a href=http://goo.gl/bG8u1v>“always maximized” TouchView</a>: <code>chrome://flags/#ash-enable-touch-view-testing</code> 를 사용하면 <code>&lt;Ctrl&gt;+&lt;Shift&gt;+&lt;Alt&gt;+D</code> 키를 사용하면 TouchView 를 최대 사이즈로 고정시킬수 있습니다.</li><li><a href=http://goo.gl/r7Omgi>Brand new chrome.i18n API</a>: <code>chrome.i18n</code> API 에 <code>getUILanguage</code> 가 추가 되었습니다.</li><li><a href=http://goo.gl/AHtOCH>Error Console has been enabled by default</a>: chrome://extentions 에서 Installed apps and extensions 의 에러를 볼 수 있습니다. #chromium</li><li><a href=http://goo.gl/mzNd9f>Sublime Text 3 plugins for Chromium development on Mac OSX</a>: Chromium 을 Sublime Text 3 에서 하고 싶다면</li><li><a href=http://goo.gl/DVW5cw>Grunt 0.4.3 released</a>: Grunt 0.4.3 이 릴리즈 되었습니다. grunt.util 에서 제공하던 여러 모듈이 이제 각각의 모듈료 존재 합니다. 이전에 사용하던 <code>grunt.util.*</code> 는 <code>grunt-legacy-util</code> 로 변경되었습니다.</li><li><a href=http://goo.gl/wXDrIf>Debugging Asynchronous JavaScript with Chrome DevTools</a>: Asynchronous javascript callbacks 의 full call stack 을 볼 수 있습니다.</li><li><a href=http://goo.gl/HsDT67>JS Live Recompilation while doing breakpoint debugging</a>: Breakpoint debugging 시에 JS 소스를 바로 수정해서 Recompile 해서 결과를 볼 수 있습니다.</li><li><a href=http://goo.gl/pLaOG8>Release Polymer Stable release 0.2.2</a>: Polymer 가 0.2.2 로 릴리즈 되었습니다. Shadow DOM Selectos 가 변경되었습니다. HTMLImports 시에 Data URIs 지원 NodeBind 관련 업데이트 등이 있습니다. <code>Vulcanize</code> 도 업데이트 되었으니 바로 업데이트 하세요.</li><li><a href=http://goo.gl/ecw6vc>Release prism-js</a>: Code highlighter prismjs 을 위한 Polymer element 입니다.</li><li><a href=http://goo.gl/4N7whj>jansepar/picturefill</a>: <a href=http://goo.gl/jXv27>The picture Element</a> 의 polyfill 프로젝트입니다. 이제 <code>&lt;picture&gt;</code> element 를 사용하세요.</li><li><a href=http://goo.gl/KCTcEq>The +AngularJS 2.0 change detection</a>: Angular.dart 에서 draft 로 구현되었던 AngularJS 2.0 Change detection 이 별도의 프로젝트로 분리되었습니다. 이름은 <code>watchtower.js</code> 이고 ES6 으로 작성되고 있습니다.</li><li><a href=http://goo.gl/suhJma>New WebP update 0.4.0</a>: WebP 가 0.4.0 으로 업데이트 되었습니다. 200% 빠른 인코딩과 25% 빠른 디코딩이 된다고 합니다.</li><li><a href=http://goo.gl/Znmuiv>x-gif A +Polymer element for flexible GIF playback</a>: GIF 를 마음대로 playback 할 수 있는 Polymer element</li><li><a href=http://goo.gl/A7XiV6>V8 hopes to ship Object.observe()</a>: <code>Object.observe()</code> 가 V8 에 land 될 예정입니다. 관련해서 여러 자료들을 먼저 살펴보세요. <code>Object.observe()</code> 는 Webapp 구조에 많은 변화를 줄 것입니다.<ul><li><a href=http://goo.gl/V9xnzu>Issue 2409 - v8 - Implement Object.observe - V8 JavaScript Engine - Google Project Hosting</a></li><li><a href=http://goo.gl/eJnZVm>Polymer/observe-js</a></li><li><a href=http://goo.gl/72Kvz5>Addy Osmani: Plight Of The Butterfly: Object.observe() – JSConf EU - YouTube</a></li></ul></li><li><a href=http://goo.gl/l9gYNq>Are Chromebooks the Future of Computing? I was recently…</a>: <a href=http://goo.gl/MSd5fV>Joe Marini</a> 가 Chromebooks 의 역사와 발전에 대해서 쓴 글입니다.</li><li><a href=http://goo.gl/z8aXUK>Extensions Manifest v3 brainstorming</a>: Extensions Manifest v3 에 대해서 활발히 논의중입니다. Promise-style API 도 제안되었네요.</li><li><a href=http://goo.gl/7uCRTG>Chromium Blog: New monetization and publishing options in the Chrome Web Store</a>: Packaged Apps 에서 Free-trial, Chrome Web Store Managed In-App Payments 가 제공됩니다.</li></ul><p></p><p><a href=/2014/04/04/webapps-monthly-digest.html>04 Apr 2014</a> - <a href=https://plus.google.com/107574899030973045541/about>+ragingwind</a></p></div><div class=post><h2>Poly, Poly, Polymer - Short introduction<span><sub class=feedurl></sub></span></h2><div><p></p><p><img src=http://www.polymer-project.org/images/logos/webcomponents.png alt="Web Components Logo"></p><p><a href=http://goo.gl/PcE1R>Polymer</a> 는 Google I/O 2013 에서 처음 소개되었습니다. <a href=http://goo.gl/tZbhQ>Web Components</a> 기반으로 만들어졌으며 Web Components 를 정형화된 방법으로 사용할 수 있는 새로운 Framework 입니다.</p><p>Webapp 을 개발하면서 가장 불편한 점 중에 하나는 표준/공식적인 방법으로 재사용이 가능한 UI Components 를 만들거나 사용하는 방법이 존재 하지 않았습니다. 다른 플랫폼에서 제공하는 Widget 들 처럼 내부 구현이 감추어지고 독립적으로 동작해서 Widget 의 사용법을 알면 되는 것과는 다르게 Boilerplate 한 코드를 매번 사용하거나 서로 다른 방식으로 사용하고 개발자가 간단하게, 이미 알려진 일반적인 방법으로 적용하기가 힘들기 때문에 서로 공유가 되지 않고 한정적으로 사용되었습니다.</p><p>위와 같은 문제를 해결 하기 위한 HTML 표준이 <a href=http://goo.gl/tZbhQ>Web Components</a> 이며, 아래와 같이 5개의 구성요소를 가지고 있으며 개발자가 Custom 하게 만든 Widget 을 생성하고 배포해서 사용하는 방법을 제공하고 있습니다.</p><ul><li><a href=http://goo.gl/3B0C4>Shadow DOM</a>: Shadow DOM 으로 독립적으로 DOM 과 Style 을 가질 수 있습니다.<sup id=fnref:1><a href=#fn:1 class=footnote>1</a></sup> 만들어진 Shadow DOM 은 기존의 Contents 와 독립적으로 Styling 을 유지하고 독립적으로 사용될 수 있어서 재사용이 가능한 Web Components 의 주요 기능이 됩니다.</li><li><a href=http://goo.gl/0VqcP>HTML Templates</a>: 내부에 있는 다른 여러 요소들은 실행/렌더링/재이 되지 않은 비활성화된 DOM 을 사용하여 클라이언트 사이드에서 언제든지 복사(Clone)해서 사용가능합니다.</li><li>Decorators <sup id=fnref:2><a href=#fn:2 class=footnote>2</a></sup></li><li><a href=http://goo.gl/EaB7p>Custom Elements</a>: 사용자가 새로운 HTML Element 를 만들 수 있습니다. 다른 Custom/General Element 를 이용해서 새로운 Composite Element 를 만들 수 있습니다.</li><li><a href=http://goo.gl/Bnh0JY>HTML Imports</a>: 만들어진 Components 를 패키지로 만들어 배포하고 공유하고 재사용 할 수 있도록 해줍니다.</li><li>그외로 Keyframe 기반으로 복잡한 Animation 을 지원하는 Web Animations Mutation Observers / MDV 그리고 Pointer Events 가 있습니다.</li></ul><p><img src=/images/posts/polymer-arch.png alt="Polymer Architecture"></p><p>Polymer 는 위의 그림과 같이 platform.js, polymer.js (Polymer core), Polymer elements 로 구성되어 있습니다. <a href=http://goo.gl/Ell1s>platform.js</a> 는 현재, 모든 모던 브라우저에서 Web Components 를 모두 지원하지 않기 때문에 모던 브라우저에서 Web Components 를 사용할 수 있도록 해주는 Polyfill 프로젝트 입니다. <a href=http://www.polymer-project.org/polymer.html>Polymer core</a> 는 platform.js 를 통해서 Web Components 를 사용하며 Polymer 의 기본적인 사용방법을 제공합니다. <code>polymer-element</code> 선언하거나 Properties 와 Methods 를 추가할 수 있으며 Element 의 Lifecycle 과 Web Components 이벤트를 제어할 수 있는 방법을 제공합니다. 마지막으로 Polymer element 는 UI Components 를 포함한 여러가지 응용 element 를 제공합니다.</p><p>현재 Polymer 는 pre-alpha mode 이며 계속 개발되고 발전하고 있는 중입니다. 표준에 친화적이고 다른 Framework 와 달리 덜 <code>Opinionated</code> 하면서 강력한 기능과 빠른 개발을 할 수 있는 Framework 입니다. 기대하고 관심을 가져보세요. 더 자세한 사용방법은 다음의 자료를 참고하세요.</p><ul><li>Google I/O 2013 에서 <a href=http://goo.gl/xjRdBk>Web Components 을 소개하는 동영상</a> 입니다. 중간에 Youtube Widget 을 이용해서 간단히 검색해서 동영상을 보여주는 부분이 인상적입니다.</li><li><a href=http://goo.gl/v9uH5a>Eric Bidelman+</a> 이 작성하는 <a href=http://goo.gl/oZ7WIb>Web Components 리소스 모음</a> 입니다.</li><li>Google I/O 2013 에서 발표된 슬라이드에 최신 내용을 업데이트 한 것입니다. <a href=http://goo.gl/Lfacj>Web Components</a> 에 대한 새로운 슬라이드입니다. 아래 슬라이드의 최신 버전입니다.<ul><li>Google I/O 2013 에서 발표된 <a href=http://goo.gl/50rV1c>Web Components</a> 에 대한 슬라이드입니다.</li></ul></li><li><a href=http://goo.gl/vulIi>Chromium Dashboard</a> 는 Polymer 로 만들어진 첫 production app 입니다.</li><li><a href=http://goo.gl/TfmnFL>Hello Polymer</a> 는 Polymer team 에서 간단한 Polymer 소개와 Q&amp;A 에 대한 영상입니다.</li><li>Mozilla 에서 제공하는 Web Compornts 를 위한 <a href=http://goo.gl/ZoYNXt>X-Tag</a> 라이브러리입니다. 같이 한번 참고하시는 것도 좋겠습니다.</li><li><a href=http://goo.gl/mvuIi8>Addy Osmani+</a> 가 <a href=http://goo.gl/qaTt1e>Yeoman 의 Polymer Generator</a> 를 사용해서 에 필요한 리소스와 코드를 자동으로 생성해서 Polymer 를 바로 사용해 볼 수 있는 방법에 대해서 설명합니다.</li><li>Github의 <a href=http://goo.gl/LvzGOy>Polymer/polymer</a> 프로젝트 입니다.</li><li><a href=http://goo.gl/SZlR42>Future CSS in Web Components</a></li></ul><div class=footnotes><ol><li id=fn:1><p>Markup encapsulation, Style boundaries. 다만 iframe 을 이용한 구현 방법는 다르게 CORS 문제나 추가적인 Network request 그리고 실제 보여지지 않아도 Redering 을 해야하는 비용에 대해서 고려해야할 필요가 없다. <a href=#fnref:1 class=reversefootnote>&#8617;</a></p></li><li id=fn:2><p>다만 Decorators 경우 아직까지 스펙이 없는 상태입니다. <a href=#fnref:2 class=reversefootnote>&#8617;</a></p></li></ol></div><p></p><p><a href=/2013/10/23/poly-poly-polymer.html>23 Oct 2013</a> - <a href=https://plus.google.com/107574899030973045541/about>+ragingwind</a></p></div><div class=post><h2>#performaters at SFHTML5<span><sub class=feedurl></sub></span></h2><div><p></p><p><img src=https://lh6.googleusercontent.com/-B4S81iHufKY/Uh_6RAeCDkI/AAAAAAAAAAA/rp2DzUgAFJU/w940-h235/event_theme.jpg alt="#performaters at SFHTML5"></p><p>동부시간 기준으로 2013-09-19 에 샌프란시스코에서 <a href=http://goo.gl/3ku1xm>#perfmatters</a> 들이 #sfhtml5 meetup 에서 Web <a href=http://goo.gl/7Wxf6>performance - HTML5 Rocks</a> 에 대한 주제로 발표와 Q&amp;A가 있었습니다. #perfmatters 는 Google IO 2013<sup id=fnref:1><a href=#fn:1 class=footnote>1</a></sup> 에서 부터 꾸준히 Chrome의 DevTools 와 Under the hood 한 내용을 바탕으로 Web performance 를 개선하는 기술들을 지속적으로 소개하고 있는데 이번 #sfhtml5 meetup 에서는 기존의 발표했던 내용을 정리하고 개선한 것을 <a href=http://goo.gl/sc9ONj>YouTube</a> 를 통해서 한자리에서 모두 볼 수 있습니다.</p><p>첫번째 세션에서는 Performance of Chrome developer relations<sup id=fnref:2><a href=#fn:2 class=footnote>2</a></sup> 의 팀리더인 <a href=https://plus.google.com/+ColtMcAnlis>+Colt McAnlis</a> 이 Javascript 에서 Manual manage(pooling), counting object 그리고 linear growth 등을 이용한 메모리 관리 방법에 대해서 설명합니다. 특히 <a href=http://goo.gl/A0I95V>해적처럼 말하기날</a> 을 맞아서 해적말투로 진행하는 것이 인상적입니다. 그리고 Chrome DevTools 의 Heap monitoring 과 Adobe 의 gcview 를 사용한 heap tracking 을 소개합니다.</p><p>두번째 세션에서는 다른 Bald 인 <a href=https://plus.google.com/+aerotwist>+Paul Lewis</a> 이 Request / Response 이후 Rendering 과정 <sup id=fnref:3><a href=#fn:3 class=footnote>3</a></sup> 과 Style, image, animation 그리고 scrolling 처리에 사용되는 비용들에 대해서 설명하고 개선시키는 방법을 설명합니다. 다음 세번째 세션은 <a href=https://plus.google.com/+jakearchibald>+Jake Archibald</a> 이 브라우저별로 이미지가 다운로드 되는 여러가지 상황을 코드와 W3C 스펙을 곁들여서 재미있게 설명합니다.</p><p>마지막 세션에서는 <a href=https://plus.google.com/+PaulIrish>+Paul Irish</a> 는 이전<sup id=fnref:4><a href=#fn:4 class=footnote>4</a></sup> 부터 계속 보여주던 스타일 대로 이미 구현된 사이트/앱들을 Chrome DevTools 로 Profiling 하고 개선시키는 데모를 보여줍니다. Frame recording 과 Frame chart 그리고 <a href=http://goo.gl/Z3IXq>Continuous painting mode</a> 를 사용해서 Bottle-neck 과 Pain-point 를 찾아내고 <code>translatez hack</code> 등을 사용하여 성능을 개선시킵니다. 그외에도 여러가지 Profiling 도구를 소개하는데요 로딩이 진행되는 동안 Rendering 된 화면도 캡처해서 보여주는 <a href=http://goo.gl/bzCd>WebPagetest</a> 이 주목할 만 합니다.</p><div class=footnotes><ol><li id=fn:1><p><a href=http://goo.gl/LeYHsn>#PERFMATTERS at Google IO 2013</a> <a href=#fnref:1 class=reversefootnote>&#8617;</a></p></li><li id=fn:2><p>Introduction to Google Developer Relations]( http://goo.gl/sUUL1j ) <a href=#fnref:2 class=reversefootnote>&#8617;</a></p></li><li id=fn:3><p>HTML parsing, DOM tree creation, Recalculate style with css, Rendering DOM tree, vector / bitmat drawing and decode and Layer composite. <a href=#fnref:3 class=reversefootnote>&#8617;</a></p></li><li id=fn:4><p><a href=http://goo.gl/v7CYfm>Chrome DevTools Timeline’s new Frame Mode - YouTube</a> <a href=#fnref:4 class=reversefootnote>&#8617;</a></p></li></ol></div><p></p><p><a href=/2013/09/20/perfmatters-at-sfhtml5.html>20 Sep 2013</a> - <a href=https://plus.google.com/107574899030973045541/about>+ragingwind</a></p></div><div class=post><h2>'Allo, 'Allo! Chrome app launcher<span><sub class=feedurl></sub></span></h2><div><p></p><p><img src=https://storage.googleapis.com/support-kms-prod/SNP_BA510FA08FF9303CA6B06D9B9E1D6E07559F_3141450_en_v1 alt="Chrome app laucher"></p><p>Chrome apps 를 Chrome book(OS) 에서 처럼 별도의 Launcher 를 공개<sup id=fnref:0><a href=#fn:0 class=footnote>1</a></sup>했습니다. 보통 Chrome browser 에서 내부 Tab 을 이용해서 Chrome app 을 구동하는 것과는 달리 Chrome book(OS) 에서 처럼 Launcher 를 통해서 바로 실행할 수 있습니다. 현재는 Windows 만을 지원하지만 다른 OS<sup id=fnref:1><a href=#fn:1 class=footnote>2</a></sup> 들도 곧 지원할 예정이라고 합니다. Chrome apps 에서는 지속적으로 Hardware API, Work Offline 그리고 Chrome Less<sup id=fnref:2><a href=#fn:2 class=footnote>3</a></sup> 를 위한 기능들을 추가 해왔는데요, 이제 유저들이 Chrome app launcher 를 사용하는 OS 에 설치한다면 Chrome book(OS) 와 동일한 경험을 가지고 Chrome app 들을 사용할 수 있게 되었습니다.</p><div class=footnotes><ol><li id=fn:0><p><a href=http://goo.gl/3xzB9F>Google Chrome Blog: A new breed of Chrome apps</a> <a href=#fnref:0 class=reversefootnote>&#8617;</a></p></li><li id=fn:1><p>Mac, Linux <a href=#fnref:1 class=reversefootnote>&#8617;</a></p></li><li id=fn:2><p>Chrome app 이 실행되는 기본 형태 주소창을 가진 기존 Chrome browser 안에서 실행되는 Webapp 과는 구분 되는 것으로 별도의 Window 를 가진다. 예를 들면 <a href=http://goo.gl/V1ciT>Text</a> 있다. <a href=#fnref:2 class=reversefootnote>&#8617;</a></p></li></ol></div><p></p><p><a href=/2013/09/16/chromeapp-launcher.html>16 Sep 2013</a> - <a href=https://plus.google.com/107574899030973045541/about>+ragingwind</a></p></div></div></div></div></div></div></div></div></div></section><section class="home posts"><h2>List</h2><article><time>18 Aug 2014</time>&raquo; <a href=/html5/2014/08/18/chrome-enchanted-notable-html5-specs-in-2014.html>Chrome Enchanted: Notable HTML5 Specifications in 2014</a></article><article><time>14 Aug 2014</time>&raquo; <a href=/2014/08/14/aboutus.html>About us</a></article><article><time>02 Jul 2014</time>&raquo; <a href=/2014/07/02/polymer-at-googleio.html>Polymer at Google I/O 2014</a></article><article><time>04 Apr 2014</time>&raquo; <a href=/2014/04/04/webapps-monthly-digest.html>Monthly Digest for Web Applications</a></article><article><time>23 Oct 2013</time>&raquo; <a href=/2013/10/23/poly-poly-polymer.html>Poly, Poly, Polymer - Short introduction</a></article><article><time>20 Sep 2013</time>&raquo; <a href=/2013/09/20/perfmatters-at-sfhtml5.html>#performaters at SFHTML5</a></article><article><time>16 Sep 2013</time>&raquo; <a href=/2013/09/16/chromeapp-launcher.html>'Allo, 'Allo! Chrome app launcher</a></article></section><script>
  (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
  function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
  e=o.createElement(i);r=o.getElementsByTagName(i)[0];
  e.src='//www.google-analytics.com/analytics.js';
  r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
  ga('create','UA-53779719-1');ga('send','pageview');
</script><footer><section class="home feeds"><p>The content of this page is licensed under the <a rel=license href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 License</a>, and code samples are licensed under the <a rel=license href=http://opensource.org/licenses/MIT>MIT License</a>. ©2013 <a href=http://github.com/webapplications-kr>WAKR (Web Applications Korea)</a> and DNS Provider by <a href=http://www.dnsever.com target=dnsever><font color=#1111f1>DNS</font><font color=#f11111>Ever</font></a></p><p></p></section></footer></main><script src=scripts/main.min.js></script></body></html>